3510. Minimum Pair Removal to Sort Array II

class Node {
public:
    int id;
    long long val;
    Node* next;
    Node* prev;

    Node(int id_num, long long value, Node* n = nullptr, Node* p = nullptr): id(id_num), val(value), next(n), prev(p) {}

    void add(Node* node) {
        node->next = next;
        next->prev = node;
        node->prev = this;
        next = node;
    }

    void remove(Node* node) {
        next->prev = prev;
        prev->next = next;
        next = nullptr;
        prev = nullptr;
    }
};

class LinkedList {
public:
    Node head;
    Node tail;
    int length;
    vector<int> sorted;
    int num_sorted;
    unordered_map<int, Node*> id_node;


    LinkedList(int n): head(-1, -1, &tail), tail(1000000, -1, nullptr, &head), length(0), sorted(n), num_sorted(0), id_node() {
        
    }

    void add(int i, int val) {
        Node* new_node = new Node(i, val);
        (*(tail.prev)).add(new_node);
        length++;
        if(new_node->prev == &head || new_node->prev->val <= val) {
            sorted[i]++;
            num_sorted++;
        }
        id_node[i] = new_node;
    }

    void remove(int i) {
        Node* node = id_node.find(i)->second;
        node->prev->next = node->next;
        node->next->prev = node->prev;
        delete node;
        id_node.erase(i);
        length--;
    }

    long long merge(int i) {
        Node* node = id_node.find(i)->second;
        int next_id = node->next->id;
        //cout << next_id << " " << sorted.size() << " " << tail.prev->id << endl;
        if(sorted[next_id]) {
            num_sorted--;
        }
        node->val += node->next->val;
        remove(next_id);
        if((node->prev != &head) && node->val >= node->prev->val && !sorted[i]) {
            sorted[i]++;
            num_sorted++;
        }
        if((node-> prev != &head) && node->val < node->prev->val && sorted[i]) {
            sorted[i]--;
            num_sorted--;
        }
        if((node->next != &tail) && (node->next->val < node->val) && sorted[node->next->id]) {
            sorted[node->next->id]--;
            num_sorted--;
        }
        if((node->next != &tail) && (node->next->val >= node->val) && !sorted[node->next->id]) {
            sorted[node->next->id]++;
            num_sorted++;
        }

        return node->val + ((node->next != &tail) ? node->next->val: 0);

    }

    bool is_sorted() {
        return num_sorted == length;
    }

};

class Solution {
public:
    int minimumPairRemoval(vector<int>& nums) {
        //unordered_map<int, int> pair_sum = {};
        multiset<pair<long long, int>> ms = {};
        LinkedList linked_list(nums.size());
        int ans = 0;

        for(int i = 0; i < nums.size() - 1; i++) {
            //pair_sum[i] = nums[i] + nums[i + 1];
            ms.insert(pair<long long, int>{nums[i] + nums[i + 1], i});
            linked_list.add(i, nums[i]);
        }
        linked_list.add(nums.size() - 1, nums.back());

        

        while(!linked_list.is_sorted()) {
            if(ms.empty()) {
                cout << linked_list.num_sorted << " " << linked_list.length << endl;
                break;
            }
            auto [_, idx] = *ms.begin();
            auto it = linked_list.id_node.find(idx);
            if(it == linked_list.id_node.end()) {
                ms.erase(ms.begin());
                continue;
            }
            long long prev_sum = it->second->val + it->second->prev->val;
            int prev_id = it->second->prev->id;
            //cout << idx << " " << _ << endl;
            long long new_sum = linked_list.merge(idx);
            ms.erase(ms.begin());
            //cout << idx << endl;
            //cout << idx << " " << linked_list.tail.prev->id << " " << (idx != linked_list.tail.prev->id) << endl;
            if(idx != linked_list.tail.prev->id) {
                //cout << idx << " " << linked_list.tail.prev->id << " " << (idx != linked_list.tail.prev->id) << endl;
                ms.insert(pair<long long, int>{new_sum, idx});
            }
            if(prev_id != -1) {
                ms.erase(pair<long long, int>{prev_sum, prev_id});
                ms.insert(pair<long long, int>{it->second->val + it->second->prev->val, prev_id});
            }
            ans++;
        }

        return ans;

    }
};